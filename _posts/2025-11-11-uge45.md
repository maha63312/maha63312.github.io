---
layout: portfolio_post
title: "Uge 46 – Revision af High-level og Low-level Design"
week: 46
elective:
  - "Backend-udvikling og API-design"
  - "Machine Learning og AI"
goals: |
  Opdatere og revidere systemdesignet på baggrund af ny læring og ændrede krav.  
  Sikre at designet afspejler den endelige event-baserede arkitektur.
  Implementere LLM ved at refaktorere HLD og LLD.
process: |
  Gennemgå eksisterende analysemateriale fra uge 38 og identificere elementer, der skal revideres.  
  Opdatere use case, systemsekvensdiagram og sekvensdiagram så de passer til det event-baserede flow.
  Tilfæje klasssediagram der illustrere flow mellem 
  Erstatte billeder med de nye, reviderede versioner.
result: |
  I uge 38 udarbejdede jeg den første version af systemets High-level og Low-level design. Den kan læses her:  
  **[Uge 38 – Analyse af systemet High-level og Low-level Design](https://maha63312.github.io/2025/09/21/uge38.html)**

  Siden da er arkitekturen blevet justeret til at gøre brug af en object key for at hente presignedUrl. Dette har påvirket både use case og sekvensdiagrammerne.

  Nedenfor er de opdaterede versioner.

  **Revideret Use Case**  
  ![Use Case – Revideret](/assets/images/UseCaseRev.png)  
  Use casen er opdateret, så den afspejler en event-baseret arkitektur, hvor en ingestiontjeneste publicerer en besked med en billedreference (`objectKey`), som AI-servicen reagerer på.

  **Systemsekvensdiagram (Event-baseret)**  
  ![Systemsekvensdiagram – Message Broker](/assets/images/ssd-messagebroker.png)  
  Systemsekvensdiagrammet viser nu, at aktøren ikke kalder AI-servicen direkte. I stedet sendes en besked til message broker, som AI-servicen konsumerer. Outputtet returneres som et nyt event.

  **Sekvensdiagram (Intern AI-flow)**  
  ![Sekvensdiagram – Event-baseret billedklassificering](/assets/images/sd-event-baseret-billedklassificering.png)  
  Sekvensdiagrammet er revideret til at vise det interne flow inden i AI-servicen, nu med hentning af billedbytes via `objectKey`, analyse via provider og efterfølgende berigelse via LLM.

  **Beskrivelse af ændringer**
  - Use casen er omskrevet til event-baseret interaktion fremfor direkte endpoint-kald.  
  - SSD viser nu message broker som kommunikationspunkt i stedet for synkront API-kald.  
  - Sekvensdiagrammet er justeret, så analysen starter ved modtaget event og ikke ved en ekstern forespørgsel.  
  - Terminologien er opdateret (fx `objectKey` i stedet for `billedeRefs`).  
  - Billeder er udskiftet med reviderede versioner, der matcher den nye arkitektur.

  Opdateringen gør systemdesignet mere præcist og i tråd med den løsning, der rent faktisk skal bygges, samtidig med at strukturen fra uge 38 fastholdes som analytisk grundlag.

  ### Visualisering af publiceringsflowet

  For at supplere det interne AI-flow med et strukturelt overblik over, hvordan resultatet publiceres, har jeg også modelleret publiceringsdelen som et DCD. Dette viser afhængigheder og flow:

  - Applikationslaget kommunikerer udelukkende via interfaces (`IRecognitionService` og `IRecognitionCompletedPublisher`).
  - `RecognitionService` danner et `RecognitionResponseDto`, som bliver mappet til et `RecognitionCompletedEvent`.
  - Mapperen er ikke vist som separat komponent i diagrammet for at holde det fokuseret.
  - Publicering sker gennem en Kafka-adapter, som implementerer porten og bruger en serializer og Kafka-producer internt.

  ![DCD – Service til Kafka Producer](/assets/images/c-dcdServiceToKafka.png)

  Diagrammet illustrerer, hvordan applikationslaget ikke har nogen afhængighedassets/images/c-dcdServiceToKafka.png til Kafka eller serialiseringsteknologi — kun til sin port. Det skaber testbarhed og   udskiftelighed, og det er netop dét, Hexagonal Architecture tilstræber.

  > **NB:** Mapper-komponenten `RecognitionCompletedMapper`, som konverterer fra `RecognitionResponseDto` til `RecognitionCompletedEvent`, er ikke vist i diagrammet for at bevare overblikket.

  ### Datamodellens struktur (DTO’er)
  
  For at supplere publiceringsflowet har jeg også modelleret de centrale DTO’er, der beskriver dataformatet for både det interne AI-resultat og det event, der publiceres eksternt. Disse DTO’er udgør den kontrakt, som andre systemer forholder sig til.
  
  - **MessageKey** indeholder reference til billedet via `objectKey` samt `correlationId`.
  - **RecognitionResponseDto** er AI-servicens interne resultat efter analyse.
  - **AIProviderDto** indeholder metadata om den anvendte provider og model.
  - **MachineAggregateDto** repræsenterer den samlede klassifikation og berigede oplysninger.
  - **RecognitionCompletedEvent** er den endelige event, der publiceres til message broker.
  
  ![DCD – DTO’er](/assets/images/c-dto.png)
  
  DTO’erne fungerer som rene datakontrakter i AI-servicen. 
  `RecognitionResponseDto` bruges internt i applikationslaget som resultat af analysen, hvorefter mapperen i adapterlaget konverterer det til et `RecognitionCompletedEvent`, som Kafka-produceren kan serialisere og publicere.
  
  Denne opdeling betyder, at applikationslaget kun arbejder med interne datastrukturer, mens adapterlaget håndterer det eksterne eventformat og selve publiceringen. Det skaber en praktisk og tydelig lagdeling mellem data, logik og infrastruktur – uden at applikationslaget behøver kende til Kafka eller eventskemaet.
  
learning: |
  Denne uge har givet en dybere forståelse af, hvordan event-baserede arkitekturer designes i praksis. 
  Jeg har især arbejdet med at adskille applikationslogik og infrastruktur gennem ports-og-adapters (Hexagonal Architecture), 
  og jeg har fået indsigt i, hvor mapping logisk bør placeres i forhold til interne DTO’er og eksterne event-formater.

  Jeg har også lært, hvordan man strukturerer dataflowet mellem AI-service, mapper og Kafka-producer, 
  samt hvordan DTO’er fungerer som datakontrakter og understøtter testbarhed og lagdeling i microservices.

  Derudover har arbejdet med opdaterede sekvensdiagrammer, systemsekvensdiagram og klassediagram 
  styrket min evne til at modellere både runtime-flow og statiske strukturer mere præcist.

next_plan: |
  Uge 47: Implementere LLM i LLD. Udarbejdelse af dokumentation for udviklere der skal gøre brug af microservicen. 

---
