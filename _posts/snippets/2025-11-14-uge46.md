---
layout: portfolio_post
title: "Uge 46 – Gemini-integration: Prompting, Schema-output og Mapping"
week: 46
categories: ["snippets"]
elective:
  - "Machine Learning og AI"
  - "Backend-udvikling og API-design"
goals: |
  Implementere en robust integration til Gemini-modellen baseret på strict JSON-schema.
  Adskille eksternt AI-output fra interne domæneobjekter ved hjælp af Ports & Adapters.
  Sikre stabil prompt-håndtering, skemaparsing og mapping til domænemodellen.
process: |
  Jeg har arbejdet ud fra Ports & Adapters-arkitekturen, hvor applikationen kun kender til
  et interface (`IMachineReasoningAnalyzer`). Selve Gemini-implementeringen ligger isoleret
  i infrastruktur-laget og kan udskiftes uden at påvirke domænelogikken.

  Arbejdet har fokuseret på tre centrale komponenter:

  - **GeminiMachineAnalyzer** – ansvarlig for API-kald, prompt, JSON-schema og parsing.
  - **GeminiPromptLoader** – indlæser templates og gør prompts vedligeholdelsesvenlige.
  - **GeminiToAggregateMapper** – sikrer korrekt mapping til vores interne DTO.
result: |
  ### GeminiMachineAnalyzer – kald til API, strict JSON og parsing

  Analyzeren bygger en prompt ud fra runtime-data, loader JSON-schema fra fil,
  sender request til Gemini og parser det strict JSON-output, modellen returnerer.
  Den fungerer som en "Adapter", som opfylder interfacet `IMachineReasoningAnalyzer`.

  **Kodesnippet (GeminiMachineAnalyzer):**  
  ![GeminiMachineAnalyzer](/assets/images/A-geminiMachineAnalyzer.png)

  **Parsing af strict JSON:**  
  ![GeminiMachineAnalyzer](/assets/images/A-parsingJsonFromGemini.png)

  Denne klasse viser:
  - generering af prompt med kontekst og værdier  
  - indlæsning af JSON-schema som kontrakt  
  - kald til Gemini 2.5 API  
  - parsing af strict JSON fra response  
  - mapping videre til intern dto  

  ---

  ### GeminiPromptLoader – template-baseret prompting

  Prompten ligger i en ekstern `.txt`-fil, så den kan revideres uden at røre koden.  
  Se mere om promptdesign i denne post:  
  **[Uge 44 – Prompt engineering og strict outputs](/snippets/2025/11/07/uge44no3.html)**

  Loaderen erstatter placeholders med værdier såsom brand, type og model.

  **Kodesnippet (PromptLoader):**  
  ![GeminiPromptLoader](/assets/images/A-promptLoader.png)

  Prompten bliver loadet fra en tekstfil:  
  ![GeminiPrompt](/assets/images/A-gemini_prompt_v0.png)

  Dette giver:
  - vedligeholdelsesvenlige prompts  
  - klare testbarhedsfordele  
  - separation mellem tekstskrivning og logik  

  ---

  ### GeminiToAggregateMapper – stærkt typet mapping

  Mapperen oversætter Gemini’s JSON direkte til vores interne `MachineAggregateDto`.
  Den håndterer også “refusal”-cases, hvor modellen afviser at give svar.

  **Kodesnippet (Mapper):**  
  ![GeminiToAggregateMapper](/assets/images/A-geminiToAggregateMapper.png)

  Mapperen sikrer:
  - stærkt typet interne data (vha. MachineAggregateDto)
  - korrekt håndtering af confidence, metadata og refusal-cases  
  - ensartede resultater på tværs af AI-modeller  

learning: |
  Jeg har lært, hvordan man designer et AI-adapterlag, der både er robust, testbart og udskifteligt.
  Strict JSON-schema har givet mig en bedre forståelse af kontraktbaseret AI-output,
  og arbejdet har tydeliggjort, hvor vigtigt det er at isolere AI-afhængigheden i infrastrukturen.

  Implementeringen har styrket mine kompetencer inden for:
  - Ports & Adapters (Hexagonal Architecture)
  - integration med LLM’er via prompt-templates
  - mapping fra eksterne AI-modeller til interne dto'er
  - forståelse af parsing, schema-validering og fejlscenarier
resources:
  - { title: "Gemini Structured Outputs – JSON Schema", url: "https://ai.google.dev/docs/structured_outputs" }
  - { title: "Ports & Adapters Architecture", url: "https://alistair.cockburn.us/hexagonal-architecture/" }
---
